
// Agar game
contract Agar {

  // address length in bits
  @addressShift = 256

  // game number length in bits
  @gameNumberShift = 32

  // cost to enter a game
  @gameEntranceFee = 0x100

  // The account storage is divided into:
  @ownerStorageKey = 0
  @playerBalance = 1
  @playerStatus = 2
  @enrolledQueue = 3
  @enrolledQueueLength = 4
  @gameCounter = 5
  @gamePlayers = 6

  // player statuses:
  @playerStatusIdle = 0
  @playerStatusEnrolled = 1
  @playerStatusInGame = 2

  // minimum number of players per game
  @minPlayers = 3

  // player rewards (in percent)
  @rewardFirstPlace = 50 // 50% * (fee x nr.players)
  @rewardSecondPlace = 30 // 30% * (fee x nr.players)
  // third place gets the rest

  // initializes the game contract by storing in the account storage the account
  // number of the creator
  // this is the only account that is allowed to update the state of the game
  define @init() {
    %parent = call @iele.caller()
    sstore %parent, @ownerStorageKey
  }

define @playerBalanceKey(%address) {
  %shifted = shift @playerBalance, @addressShift
  %ored = or %shifted, %address
  ret %ored
}

define @playerStatusKey(%address) {
  %shifted = shift @playerStatus, @addressShift
  %ored = or %shifted, %address
  ret %ored
}

define @gamePlayersKey(%gameIndex) {
  %shifted = shift @gamePlayers, @gameNumberShift
  %ored = or %shifted, %gameIndex
  ret %ored
}

define public @balanceOf(%playerAddr) {
  // get the key for the account in the balance region
  %balanceKey = call @playerBalanceKey(%playerAddr)

  // get and return the account's current balance
  %balance = sload %balanceKey
  ret %balance
}

// transfer funds to contract to top up player account
define public @topUp() {
  %playerAddr = call @iele.caller()
  %amount = call @iele.callvalue()
  %balanceKey = call @playerBalanceKey(%playerAddr)
  %balance = sload %balanceKey
  %balance = add %balance, %amount
  sstore %balance, %balanceKey

  ret void
}

// as a player, withdraw tokens from the contract account
define public @withdraw(%amount) {
  %playerAddr = call @iele.caller()
  %balanceKey = call @playerBalanceKey(%playerAddr)
  %balance = sload %balanceKey

  // ensure that the player balance can cover the value to be withdrawn
  %lt = cmp lt %balance, %amount
  br %lt, throw

  %balance = sub %balance, %amount
  sstore %balance, %balanceKey

  // return funds by calling deposit at the player account
  %gas = call @iele.gas()
  %status = call @deposit at %playerAddr () send %amount , gaslimit %gas
  br %status, throw // contract call failed
  ret void

throw:
  call @iele.invalid()
}

// as a player, withdraw all owned funds from the contract account
define public @withdrawAll() {
  %playerAddr = call @iele.caller()
  %balanceKey = call @playerBalanceKey(%playerAddr)
  %balance = sload %balanceKey

  %isBalanceZero = cmp eq %balance, 0
  br %isBalanceZero, return

  sstore 0, %balanceKey

  // return funds by calling deposit at the player account
  %gas = call @iele.gas()
  %status = call @deposit at %playerAddr () send %balance , gaslimit %gas
  br %status, throw // contract call failed

return:
  ret void

throw:
  call @iele.invalid()
}

// player enrols herself
define public @enrol() {
  %playerAddr = call @iele.caller()

  // change status idle -> enrolled
  %statusKey = call @playerStatusKey(%playerAddr)
  %status = sload %statusKey
  %notIdle = cmp ne %status, %playerStatusIdle
  br %notIdle, throw
  sstore @playerStatusEnrolled, %statusKey

  // subtract game entry fee (if enough funds are present)
  %balanceKey = call @playerBalanceKey(%playerAddr)
  %balance = sload %balanceKey
  %lt = cmp lt %balance, @gameEntranceFee
  br %lt, throw
  %balance = sub %balance, @gameEntranceFee
  sstore %balance, %balanceKey

  // add player to queue (to the left)
  %queue = sload @enrolledQueue
  %queueLength = sload @enrolledQueueLength
  %shift = mul %queueLength, @addressShift
  %playerAddr = shift %playerAddr, %shift
  %queue = or %queue, %playerAddr
  sstore %queue, @enrolledQueue

  // increment queue length
  %queueLength = add %queueLength, 1
  sstore %queueLength, @enrolledQueueLength

  ret void

throw:
  call @iele.invalid()
}

// owner starts a game, takes player from the list
define public @startGame(%nrPlayers) {

  // check that call comes from owner
  %caller = call @iele.caller()
  %owner = sload @ownerStorageKey
  %notOwner = cmp ne %caller, %owner
  br %notOwner, throw

  // check queue length
  %queueLength = sload @enrolledQueueLength
  %notEnoughEnrolledPlayers = cmp lt %queueLength, %nrPlayers
  br %notEnoughEnrolledPlayers, throw

  // load queue
  %queue = sload @enrolledQueue
  %nrRemainingEnrolled = sub %queueLength, %nrPlayers

  // process players entering game one by one
  %addressMask = shift 1, @addressShift
  %addressMask = sub %addressMask, 1
  %i = %nrPlayers
  %gamePlayers = 0
  %shiftRight = sub 0, @addressShift
  
playerLoop:
  %player = and %queue, %addressMask
  %invalidPlayer = cmp eq %player, 0
  br %invalidPlayer, throw
  
  %notEnoughEnrolledPlayers = cmp eq %player, 0
  br %notEnoughEnrolledPlayers, throw

  %done = cmp eq %i, 0
  br %done, allPlayersProcessed

  // add player to player list
  %gamePlayers = shift %gamePlayers, @addressShift
  %gamePlayers = or %gamePlayers, %player

  // save player status as in game
  %statusKey = call @playerStatusKey(%player)
  sstore @playerStatusInGame, %statusKey
  
  // update counter and queue registers
  %i = sub %i, 1
  %nrRemainingEnrolled = sub %nrRemainingEnrolled, 1
  %queue = shift %queue, %shiftRight

  br 1, playerLoop

allPlayersProcessed:

  // update queue
  sstore %queue, @enrolledQueue
  //sstore %nrRemainingEnrolled, @enrolledQueueLength

  // retrieve and increment game counter
  %gameIndex = sload @gameCounter
  %newGameCounter = add %gameIndex, 1
  sstore %newGameCounter, @gameCounter

  // save game players
  %gamePlayersKey = call @gamePlayersKey(%gameIndex)
  sstore %gamePlayers, %gamePlayersKey

  ret %gameIndex, %gamePlayers

throw:
  call @iele.invalid()
}

// owner ends a game and distributes rewards
define public @endGame(%gameIndex, %winners) {

  // load game player list
  %gamePlayersKey = call @gamePlayersKey(%gameIndex)
  %gamePlayers = sload %gamePlayersKey

  // clear game data
  sstore 0, %gamePlayersKey

  %badGameIndex = cmp eq %gamePlayers, 0
  br %badGameIndex, throw
  
  // set all game player states to 0 (idle)
  %addressMask = shift 1, @addressShift
  %addressMask = sub %addressMask, 1
  %shiftRight = sub 0, @addressShift
  %playerCount = 0
  
playerStatusLoop:
  %player = and %gamePlayers, %addressMask
  %isZero = cmp eq %player, 0
  br %isZero, allPlayersProcessed

  // save player status as idle
  %statusKey = call @playerStatusKey(%player)
  sstore @playerStatusIdle, %statusKey

  %playerCount = add %playerCount, 1
  %gamePlayers = shift %gamePlayers, %shiftRight

  br 1, playerStatusLoop

allPlayersProcessed:

  // compute prizes
  %totalPrize = mul %playerCount, @gameEntranceFee
  %firstPrize = mul %totalPrize, @rewardFirstPlace 
  %firstPrize = div %firstPrize, 100
  %secondPrize = mul %totalPrize, @rewardSecondPlace
  %secondPrize = div %secondPrize, 100
  %thirdPrize = sub %totalPrize, %firstPrize
  %thirdPrize = sub %thirdPrize, %secondPrize

  // reward 3rd prize
  %player = and %winners, %addressMask
  %badWinners = cmp eq %player, 0
  br %badWinners, throw
  %balanceKey = call @playerBalanceKey(%player)
  %balance = sload %balanceKey
  %balance = add %balance, %thirdPrize
  sstore %balance, %balanceKey
  %winners = shift %winners, %shiftRight

  // reward 2nd prize
  %player = and %winners, %addressMask
  %badWinners = cmp eq %player, 0
  br %badWinners, throw
  %balanceKey = call @playerBalanceKey(%player)
  %balance = sload %balanceKey
  %balance = add %balance, %secondPrize
  sstore %balance, %balanceKey
  %winners = shift %winners, %shiftRight

  // reward 1st prize
  %player = and %winners, %addressMask
  %badWinners = cmp eq %player, 0
  br %badWinners, throw
  %balanceKey = call @playerBalanceKey(%player)
  %balance = sload %balanceKey
  %balance = add %balance, %firstPrize
  sstore %balance, %balanceKey
  %winners = shift %winners, %shiftRight

  // check that the number of inputs in %winners is correct (i. e. 3)
  %badWinners = cmp ne %winners, 0
  br %badWinners, throw

  ret void

throw:
  call @iele.invalid()
}

}